# Aurora 自举路线图 (Stage N1 → Self-Hosting)

## 为什么暂时用 JavaScript

当前 pipeline 使用 Node.js/JavaScript 实现是临时性的引导策略：

1. **快速原型验证**：JS 无需编译步骤，可以快速迭代解析、IR 生成和指令编码逻辑。
2. **降低初始门槛**：在 Aurora 语言本身尚未成熟时，需要一个宿主语言来引导第一版编译器。
3. **逻辑验证先行**：先用 JS 验证编译流程的正确性，再迁移到原生实现，避免同时调试语言设计和底层代码。

## 构建原生二进制编译器的演进路径

### Stage N1（当前阶段）
**目标**：用 JS 实现完整的 `.aur` → `.aurs` 流水线，验证 IR 设计和指令编码逻辑。

- ✅ 字符串打印程序支持
- ✅ 算术循环程序支持
- ⏳ 扩展语法覆盖（条件分支、函数调用、更多算术运算）
- ⏳ 完善 IR 抽象层
- ⏳ 自动化测试与回归验证

**交付物**：可运行的 Node.js CLI，能生成与 legacy C 实现完全一致的 manifest。

### Stage N2（Aurora 自举准备）
**目标**：用 Aurora 重写编译器核心逻辑，由 JS 或简化的 C 运行时引导执行。

**实施步骤**：
1. 在 `pipeline/src/aurora/` 下用 Aurora 语言实现：
   - 词法分析器（Lexer）
   - 语法分析器（Parser）
   - IR 构建与类型检查
   - 指令编码与 manifest 生成
2. 编写薄层 JS/C shim，负责：
   - 文件 I/O 和命令行参数解析
   - 调用 Aurora 实现的编译器核心
   - 输出最终 manifest
3. 逐步迁移功能模块，保持 JS 原型作为参考实现。

**验证方式**：Aurora 实现与 JS 原型输出完全一致。

### Stage N3（原生二进制生成）
**目标**：Aurora 编译器能输出原生可执行文件（ELF/PE），完全脱离宿主依赖。

**实施步骤**：
1. 扩展 Aurora 编译器后端，支持：
   - 机器码生成（x86-64/ARM64）
   - 目标文件格式（ELF/PE/Mach-O）
   - 链接器集成或自研链接器
2. 实现运行时库（minimal libc）：
   - 系统调用封装（write/exit/mmap 等）
   - 内存管理（堆/栈）
   - 基础 I/O
3. Aurora 编译器可以编译自身的 Aurora 源码为独立二进制。

**交付物**：`aurc` 原生可执行文件，可在无 Node.js 环境下运行。

### Stage N4（完全自举）
**目标**：Aurora 编译器完全用 Aurora 编写，编译自身，生成原生二进制。

**实施步骤**：
1. 用 Stage N3 的原生编译器编译自身的 Aurora 源码。
2. 验证新生成的编译器能再次编译自身（bootstrap 验证）。
3. 移除所有 JS/C 宿主代码，仅保留用于种子的初始二进制。

**里程碑**：Aurora 成为完全自托管的编程语言。

## 当前行动项
- 继续完善 Stage N1 的 JS 原型，覆盖更多语法。
- 设计 Aurora 侧的编译器 API（为 N2 做准备）。
- 编写 Aurora 语言核心库（字符串、容器、I/O）。
- 规划 minimal ISA 到机器码的映射策略（为 N3 做准备）。

## 为什么这个路径可行
1. **渐进式迁移**：每个阶段都有可验证的交付物，避免大爆炸式重写。
2. **双轨验证**：JS 原型和 Aurora 实现可以互相对照，确保语义一致。
3. **历史经验**：OCaml、Rust、Go 等语言都采用类似的自举路径。
4. **技术债可控**：JS 原型在完成使命后可以归档，不会成为长期维护负担。

本路线图将随着实现进度持续更新。
